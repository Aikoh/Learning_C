# Learning_C
プログラミング教育C言語
---
### Lesson 1 C言語の構造
```
int main(void){
    return 0;
}
```
```
型 関数名(引数){
    処理
}
```
---?code=helloWorld.c

### Hello,World!
とりあえず、動かしてみよう！

---
```
#include <stdio.h>

int main(void){
  printf("Hello,World!");
  retrun 0;
}
```
printfという部品がどのように動くものか、どのように使うものかが書いてあり「ライブラリ」を最初に紐づけています。

”Hello,World!”　これは　”文字列”　を表示したい中身を表しています。

---?code=math.c
### 数字と計算

---
### 変数

#### 変数とは

---
### 変数の種類

 - int
 - floot
 - double
 - char

---
### 整数と実数

---
### 10進数 8進数 16進数 2進数

#### 10進数　10
#### 8進数　 012
#### 16進数　0xA
#### 2進数　 1010

---
### Lesson2 条件分岐

#### if文


---
### Lesson3 繰り返し処理

---
### Lesson4 繰り返し処理

---
### Lesson5 関数の作成

---
### Lesson6 配列

---
### Lesson7 文字列

今まで、文字を扱う変数を避けてきました。

Ｗｈｙ？<br>
それは、Ｃ言語には文字列を扱う変数がないからです。
でも、文字を扱う変数はあります。<br>
従って、文字列を扱うには工夫が必要なのです。
工夫できるほどの知識が必要となるのです。

---
### 文字変数

文字変数の型はcharです。

そして、文字を表す為に'クォテーションで囲みます。例えば
```
'A'
```
@[1] (こんな具合です。''←これの間に入る文字を文字変数の中身として扱われます。)

---?code=mojisample1.c

出力結果は次のように表示されます。<br>
A

---
### Charが扱えるのは半角だけ

char型は最大255文字以内の表現しか記録できない。<br>
英語はABCDE FGHIJ KLMNO PQRST UVWXY Z <br>
26文字の大文字と26文字の小文字の合計52文字で表現できる。

コンピュータは英語圏で生まれたものだから、<br>
当初は記号を含めて、127文字の表現で使えるものがあれば十分<br>
だった。そこで、7bit（7ケタの２進数）で表現できる文字コード<br>
ASCIIコードを作った。
---
### 文字コードとは

コンピュータは最終的には2進数で表現される。<br>
そこで、数字と文字を紐づけた形で対応表を作り
文字を表現していた。<br>

ASCIIコードの一部抜粋

<table>
<tr>
  <td>65</td>
  <td>A</td>
</tr>
<tr>
  <td>66</td>
  <td>B</td>
</tr>
<tr>
  <td>67</td>
  <td>C</td>
</tr>
</table>

例えば、上記のようにコンピュータのすべての文字は
番号で管理されている。

---
### char型の仕組み

実は、char型は文字のコードである数字を扱っている。
そこで、char型に足し算をする事で扱う文字を変更する事ができる。

---?code=charadd.c
### 文字の計算

---
### 「数字」と「数値」

実は、文字としての数字もASCIIコードにあります。
下記の表は一例ですが、0という数字は48に割り当て
られています。

<table>
<tr>
  <td>48</td>
  <td>0</td>
</tr>
<tr>
  <td>49</td>
  <td>1</td>
</tr>
<tr>
  <td>50</td>
  <td>2</td>
</tr>
</table>

---?code=calcmoji.c
###数字の数値変換

---
数字は計算に使えません。しかし、割り当てられた
数値コードを引いた値を数値を扱う型の変数に入れる
事で計算可能になります。

ただし、この方法では数字以外の文字が入ってきた場合
も数値化してしまいます。

---?code=judgnumber.c

### 数字以外は数値化しない範囲指定をする。

---

char型はコード表に従って文字を扱っているが、
文字コードの範囲を制御したい場合、英字の大文字と
小文字は連続した数値が割り当てられていません。<br>
そこで、いちいち判定を書かなくても良いように
あらかじめ関数が用意されています。<br>

---?code=ctype.c

---
### char型は1文字しか扱えません。
しかし、char型の配列を用意すれば文字列のように
扱えそうです。

さて、そもそもなんでC言語は文字列を扱う変数が
無かったのでしょうか？
それは、文字列は何文字必要かがわからないという
問題があります。
例えば「Hello」は5文字です。「Morning｣ は
7文字です。このように言葉によって文字数が
変わります。

---
### EOS（End of String)文字の最後

文字列は何文字あるかわかりません。文字がいくつあるか？<br>
数がわからないと扱う事が難しいです。
これは、中身の見えない箱の中に手を突っ込んで、中に入っているボールを取り出しなさい。ただし、１回につき１つまでしか取り出せず、最初に何回取り出すかを決めなさい。と言われたら困ってしまいますよね？そんなイメージです。
そこで、ここで最後ですよ。という印をつける事にしました。その印が'\0'になります。

---?code=eos.c

### 初期化の場合は、０を省略しても最後に0が入る。

char str[10] = {'T','h','e','W','a','g','g','l','e'};

---?code=Strliteral.c

### 初期化のみ"文字列リテラル"をつかった代入が可能

---?code=inString.c

### 文字列の入力方法

---

### Lesson 8 コンピュータの基礎（メモリー）

---

### ﾒﾓﾘのイメージ

#### [ ] １個の入れ物をイメージしてください。

####　メモリには番号がつけられている
[0][1][2][3][4][5][6][7][8][9][10][11][12][13]・・・・・・[][500000000]･･

####　メモリの中身が入ってたら１入ってなかったら０という状態管理をしている。
[0][0][0][0][0][0][0][0][0][0][0][0][0][0]・・・・・・[][0]・・

#### 中身は2進数で記憶している数値
0と１の組み合わせで記憶している。

---

### ＣＰＵ　の　x86、x64とは？

####　細かすぎて使うのが大変なので、ある程度まとめて使おう。そこで８個ずつまとめて扱う事にした。
　[0][0][0][0][0][0][0][0]<br>[0][0][0][0][0][0][0][0]<br>[0][0][0][0][0][0][0][0]<br>[0][0][0][0][0][0][0][0]

#### x86とはCPUが一度に取り扱えるデータの数が32bit
#### x64とはCPUが一度に取り扱えるデータの数が64bit

そこで8bitを１つの単位として扱うように１byteとし、
32bitのCPUでは32bitで表現できる0から約42億くらいの
番号が割り当てられている。

###### ※　x86が32bitなのは昔8086という16bitのCPUを作ったのが起源で、このバージョンに対応した形で32bitに拡張した為

---
### アドレス
変数につけられたメモリ上での番号

####　メモリは１byte事に番号をつけて区別している。

#### 変数の宣言をしたときにメモリを確保して番号を付与する。
[][][][][][][][]<br>[][][][][][][][]<br>[][][][][][][][]<br>[][][][][][][][]<br>

---?code=memory.c

#### 16進数のアドレスが表示されます。
4bit * 8桁 = 32bitの表現をしている

#### 16進数｢007CF914｣　→　10進数「7340032+786432+61440+2304+16+4｣(8190228)

#### 数値は環境が替わると変化します。

---

#### i1,i2,i3の変数のアドレスは連番とは限りません。理由は、別々に扱われる変数だから連番の必要がありません。
#### 配列は○○番違いで表示されます。○○番はint型で扱われるバイト数により違います。私の環境はint型は4バイトですので、4番違いで表示されます。

---?code=array.c

---
### Lesson9 ポインタ
---
関数を作成した時の引数の仕組みのおさらい
```
int kansu_name(int input){
  int absult;
  abusult = absult * abult;
  return abusult;
}
```
例えば、上記のkansu_name関数でint inputと書かれている部分は「引数」と呼ばれている部分でした。
引数という部分は、関数に数値を渡す事ができる仕組みです。

---
しかし、この引数で渡す事ができるのは数値で、この関数を呼び出す時に下記のように変数を利用した場合は内部では変数に記憶されている値を、呼び出した関数の実引数に複製している状態です。
```
int main(void){
  int hensu = 2;
  kansu_name(hensu);
}
```
---
### 値渡し

引数で関数に渡されるデータは、すべて数値になります。
これを値渡しと呼ぶ事があります。

値渡しというのは、変数を実引数にしても、渡されているのは変数に格納している数値で、もとの変数には影響を受けません。それは、関数に渡されているのは変数ではなく、変数の中の数値を複製したものだからです。

---

### 関数でのアドレス渡し

関数側でもとの変数の数値を変換する処理をしたい場合はどうすればいいでしょうか？

そこで、変数のアドレスを直接指定して数値が格納されているメモリ上の位置（番号）がわかれば直接メモリの中身を書き換える事ができるようになります。そうする事で呼び出し側の変数を書き換える事が可能になります。

---?code=pointer.c
### ポインタを使って関数内の処理で変数を更新

---
### ポインタ

例えばさっきの例で呼び出したtri関数は１回目に呼び出した結果と2回目に呼び出した結果が変わっています。
```
printf("%d,%d\n", x, y);
printf("1回目の処理 %d\n",tri(x, y));

printf("%d,%d\n", x, y);
printf("2回目の処理 %d\n", tri(x, y));
```
これは、関数の中でメモリの値を変更しているからです。

こういった事を実現する為の機能の総称を「ポインタ」といいます。

---

### ポインタの機能に必要な３つの要素

ポインタとは機能の総称といいました。その機能を実現するのに必要な３つの要素があります。

1. ポインタ型
1. ポインタ値
1. ポインタ変数

---

### ポインタ型

- 型とポインタ型を組み合わせる
```
int *x;
doble *y;
char *c;
```
型により、メモリの仕様量が異なるのでどんな型の
変数のアドレスかを把握する必要がある

---
### ポインタ値

- ポインタ値とはアドレスの事を指します。

int型と区別している理由は、他の数値とは使用目的が違う為、混乱しないで済むように明確に分けて扱っています。

---
### ポインタ変数

- ポインタ型で宣言された変数の事
- ポインタ変数は変身ヒーローみたいな役割<br>
変身ヒーローというより、動物が擬人化して何かできるようになるアニメものみたいな感じ

```
int *pointa //int型のポインタ型を宣言している
/*pointa部分は変数名*/
```

- 変身前の状態がポインタ変数
- 変身後の状態がノーマル変数
<br><br>
- ポインタ変数　：アドレスへの代入と足し算と引き算
- ノーマル変数　：普通の変数と同様の演算が行える

---
### ポインタ型の引数

関数の中で処理した情報を戻り値を使って返すのが、一番簡単な方法ですが、この方法では、常に1つの情報しか返せません。

2つ以上の情報を返したい時などに困ります。
そこで、ポインタ型の引数を使います。

---
ポインタ型はアドレスを受け取ることが出来るので、
関数を呼び出す時に、既に存在する変数のアドレスを指定してあげれば、呼び出された関数側で受け取ったアドレスをポインタ変数に代入し、ポインタ変数をノーマル変数に切り替えて、返す情報を代入する事でポインタを呼び出した変数に記憶されているという状態になります。

---?code=p_value.c

---
Lesson9 小テスト

1. 変数についたメモリ上の数値はなんという名前ですか？
 1. １.の数値を変数に代入して扱う方法の総称はなんという呼び方か？

---
- 下記のプログラムを読み取りなさい。tri関数がvoid型にも関わらず、tri関数の結果を返す事ができている理由を述べなさい。

```
 #includ <stdio.h>

 void tri(int,int,int*;)

int main(void){
  int value;
  tri(10,15,&value);
  printf("%d\n",value);
  return 0;
}

void tri(int width, int hight, int *area){

  *area = width * hight / 2;
  return;
}

```
---

### Lesson 10 ポインタと配列

---

### 配列型の引数

---
